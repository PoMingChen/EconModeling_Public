---
title: "Final_Project_EduSignal"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## makecondition

```{r}
library(reticulate)
```


```{python}
from numpy.random import default_rng
from numpy import mean
```


### Final Trial on Candidate and Employer Class Interaction

先從 Employer 本身的 Belief，以及他本身願意給人才和庸才各自多少，分別即是（Low, High, Wage_Schedule）。
```{python Employer}
class Employer:
  
   #想要一般化的話，這邊可以多高薪要多高，低薪要多低。也更容易一般化 Google TSMC 等頂尖企業
    def __init__(self, Low, High, Wage_Schedule):
        self.Wage_Schedule=Wage_Schedule
        self.Low = Low
        self.High = High
       
     
    def Possible_Wage(self, Signal):
        Wage_Schedule = self.Wage_Schedule
         #In Spence, one candidate instance provide one signal, this is 1(employer) to N(candidates) game. But the concern comes from the reality that Signal is not a attribute belong to Employer. It's like a important, external information
        # Employer.Signal = Signal
        if(Signal >= Wage_Schedule):
          return self.High
        else:
          return self.Low
    
    def Check_Eqm(self):
        # 看起來是可行的。但是權限大到基本上就是 Mr.JobMarket，用 Mr.JobMarket 的視角在看 Mr.JobMarket 操作的 Eqm-related methods，還在想要不要這樣。
        #Check_Eqm(self, employer, candidate)，employer 等於是自己。但是若寫
        #Check_Eqm(self, candidate)
        # self.jobmarket_result = JobMarket(employer=self, candidate) 會不對，是凸顯變成Mr.JobMarket事實
        self.jobmarket_result_Separating = JobMarket.Separating_Eqm(self)
        self.jobmarket_result_Pooling = JobMarket.Pooling_Eqm(self)
    # 還有一個可能性是 Mr.JobMarket 做完 Eqm evaluation 之後，他單純借過來看，沒有 Input Arguments 作為阻擋或者 access friction，但是尚未確定是否做得到。
    #就是 NoAdditionalArguments in method instruction and after JobMarket.xxxmethod e.g.JobMarket.SeparatingEqm(NoAdditionalArguments), return true false and possible paste0 expression about the Group and Signal to mimic the realization after hiring the candidate instance.(But, build the JobMarket.SeparatingEqm... as soon as possible. )
    # def Check_Eqm(self, NoAdditionalArguments):
    #     self.jobmarket_result1 = JobMarket.SeparatingEqm(NoAdditionalArguments)
    #     self.jobmarket_result2 = JobMarket.Pooling1Eqm(NoAdditionalArguments)
    #     self.jobmarket_result3 = JobMarket.Pooling3Eqm(NoAdditionalArguments)

#EOF
```


```{python Class_JobMarket}
class JobMarket:
  def __init__(self, employer, candidate):
    self.employer = employer
    self.candidate = candidate
  def Separating_Eqm(self):
    Group = self.candidate.Group
    Signal = self.candidate.Signal
    Wage_Schedule = self.employer.Wage_Schedule
    
    if ((Group == 1 and Signal == 0) or
       (Group == 2 and Signal == Wage_Schedule)):
        return "One more glance to check candidate from another Group(Type), therefore, the Separating Eqm will be more convincing."
    else:
        return "Check the scenario of Pooling Eqm."
      
  def Pooling_Eqm(self):
    q1 = self.candidate.__class__.q1
    Group = self.candidate.Group
    Signal = self.candidate.Signal
    Wage_Schedule = self.employer.Wage_Schedule

    if (Group == 2 and Signal == 0):
        return "The Group2(The talent) have no incentive to signal since q1*2 < Wage_Schedule: " + str(q1) + " * 2" + " < " + str(Wage_Schedule)
    elif (Group == 1 and Signal == Wage_Schedule):
        return "The Group1(The normal) are urged to signal by market structure since Wage_Schedule < 1-q1: " + str(Wage_Schedule) + "1-" + str(q1)
    else: 
        return "Check if there is Separating Eqm."
     
#EOF
```


```{python SimpleSpence}
SimpleSpence = JobMarket(employer = Employer(Low=1, High=2, Wage_Schedule=1.4),
                         candidate = Candidate(Group=2, Low=1, High=2, Wage_Schedule=1.4))
```

```{python SimpleSpence_candidate}
SimpleSpence.candidate.__class__.Low
SimpleSpence.candidate.__class__.High
SimpleSpence.candidate.__class__.Wage_Schedule
SimpleSpence.candidate.__class__.candidate1toN #Only himself
SimpleSpence.candidate.Population()
SimpleSpence.candidate.__class__.candidate1toN #500 candidates(first one is himself)
SimpleSpence.candidate.q1()
SimpleSpence.candidate.__class__.q1
SimpleSpence.candidate.Uniform_Payoff() #q1*1+(1-q1)*2
SimpleSpence.candidate.__class__.Uniform_Payoff
SimpleSpence.candidate.Group
SimpleSpence.candidate.Signaling_Cost(Education=2)
SimpleSpence.candidate.Optimal_Education()
SimpleSpence.candidate.Signal
# SimpleSpence.candidate.__class__.candidate1toN[500].Group 
```

```{python SimpleSpence_employer}
SimpleSpence.employer.High
SimpleSpence.employer.Low
SimpleSpence.employer.Wage_Schedule
SimpleSpence.employer.Possible_Wage(SimpleSpence.candidate.Signal)

```
Start with the Pooling_Eqm method can be more handy since we want to avoid it.
```{python SimpleSpence1_Pooling_Eqm}
SimpleSpence.Pooling_Eqm()
```

```{python SimpleSpence1_Separating_Eqm}
SimpleSpence.Separating_Eqm()
```

```{python}
SimpleSpence.employer.Check_Eqm()
```


```{python Candidate}
class Candidate: 
    
    candidate1toN = []
    
    def __init__(self, Group, Low, High, Wage_Schedule):
        assert (Group in (1,2)), "The candidate is either low-type(Group=1) or high-type(Group=2)"
        self.Group = Group
        self.employer = Employer(Low, High, Wage_Schedule)
        Candidate.Low = self.employer.Low
        Candidate.High = self.employer.High
        Candidate.Wage_Schedule = self.employer.Wage_Schedule
        Candidate.candidate1toN.append(self)
        
    def Signaling_Cost(self, Education):
       assert (Education >= 0), "Education level is >=0"
       Group = self.Group
       Signaling_Cost = Education/Group
       return Signaling_Cost
    
    #For the class variable Uniform_Payoff, it has to wait the class method.
    def Optimal_Education(self):
        Low = Candidate.Low
        High = Candidate.High
        Wage_Schedule = Candidate.Wage_Schedule
        Group = self.Group
        Uniform_Payoff = Candidate.Uniform_Payoff
        Net_Return_of_Signal1 = Low - 0/Group
        Net_Return_of_Signal2 = High - Wage_Schedule/Group
        Net_Return_of_Signal3 = Uniform_Payoff - Wage_Schedule/Group
        
        if max(Uniform_Payoff,Net_Return_of_Signal2)==Net_Return_of_Signal2:
            self.Signal = Wage_Schedule
            return Wage_Schedule
        elif max(Net_Return_of_Signal1,Net_Return_of_Signal3)==Net_Return_of_Signal3:
            self.Signal = Wage_Schedule
            return Wage_Schedule
        else:
            self.Signal = 0
            return 0
     
    #candidate_1to500[1].__class__.candidate1toN return N Candidate instance
    @classmethod
    def Population(cls, N=500):
        
        rng_seed = default_rng()
        Other_candidates_Initiation = [
          Candidate(Low=cls.Low,
                    High=cls.High,
                    Wage_Schedule=cls.Wage_Schedule,
                    Group = int(rng_seed.integers(low=1, #inclusive
                                                   high=3, #exclusive
                                                   size=1))) for i in range(N-1)
        ]
        Population = len(Other_candidates_Initiation) + 1
        cls.Population = Population
        return Population
    
    
    #先建立 classmethod 得到 q1。這樣就算是 500 個申請者有甦醒了。後續也要進到市場之後，才會去看到 wage
    @classmethod
    def q1(cls):
        #有無機會把 rng(500) 容在這裡面？變得說甦醒的時候，我首先當然知道自己的 type，下一刻我會去問那這個世界的人才和庸才的比例狀況怎麼樣？（或者你再多一個 class method，因為你 proportion 用了 cls.candidate1to500。最終是希望可以一樣在 class variable 有一個 candidate500，這是所有 candidates 都知道的事情（但是要小心 Employer 會不會因此都看得到大家）
        proportion = mean([cls.candidate1toN[i].Group for i in range(cls.Population)])
        Group1_proportion = 2-proportion
        
        #Initiate the class variable q1 
        cls.q1 = Group1_proportion 
        return Group1_proportion
      
    #建立 classmethod 需要分開寫。申請者先掃過一眼自己的競爭者 Type 比例。然後如果計算如果不做 signaling，Uniform_Payoff 報酬是多少？
    @classmethod
    def Uniform_Payoff(cls): 
        Low = cls.Low
        High = cls.High
        q1 = cls.q1 #q1 is awared by the initial(previous class method)
        Uniform_Payoff = Low*q1 + High*(1-q1)
        
        #Initiate the class variable Uniform_Payoff
        cls.Uniform_Payoff = Uniform_Payoff
        return Uniform_Payoff

#EOF
```


### Self-Relection

1. Signaling_Cost = Education/Group。有 Group1, 2，但是他們的生產力效率可以不見得是 1:2，可以是 1:5 甚至是 1:10 之類的。表達（庸才, 人才），（庸才，將才），（庸才，將將之才）的差別。自然也會影響到若 $q1 > \frac{a2}{a1}$ 成立，人才會有意願 Signaling 的可能性。（這邊最好再說一下 cost = a1y）等等。





